---
subtitle: "Coding principles"
---

```{r}
#| echo: false
#| warnings: false
#| message: false
library(EVR628tools)
library(tidyverse)
```

## So Far

- You've trusted me and executed code as instructed
- I didn't give you much background on what you were doing
- Clearly something clicked; you are still here
- Let's give you a bit more background

## Learning Objectives

:::{.callout-note}
## By the end of this week, you should be able to:
- Know about "atomic" objects and how they relate to all things R
- Understand and check object classes
- Index and subset vectors and data frames
- Explain the importance of code style and documentation
- Use the `pipe` operator
:::

# "Objects" and "Classes"

## Object _classes_

The most common _atomic_ classes are:

- character: `"a"` or `'b'` (note the quotation marks)
- numeric: `2` or `10e3` (note scientific notation)
- logical: `TRUE`/`FALSE` or `T`/`F`, but never `true`/`false` (note no quotations)

. . .

:::: {.columns}

::: {.column width='50%'}
You can check classes with function `class()`

```{r}
#| code-fold: false
class("a")

class(2)

class("2") # This is no longer a number

class(TRUE)
```


:::

::: {.column width='50%'}

Coercing "up" is safe

```{r}
#| code-fold: false
as.character(20)
as.numeric(TRUE) # Logical to numeric
```

Coercing "down"... not always

```{r}
#| code-fold: false
as.numeric("a") # Character to numeric
```


:::

::::

## Object _classes_

Classes in R map to the types of data we during Week 2:

- _numerical_ data in R are of _class_ `numeric`
- _cetegorical_ data in R are of _class_ `character`
- _ordinal_ data in R are a special _class_ of `character` called `factor`
  - Remember when we ordered the axis label in a ggplot using `fct_infreq()`?

## Creating "objects"

- If you'll need a value, dataset or plot for later, you should "assign it"
- This will retain the object in your **environment** tab, leaving available for later
- You will use the _assignment operator_: `<-`
  - Mac shortcut: `Opt` + `-`
  - Windows shortcut: `Alt` + `-`
- Read "`<-`" as: "gets a value of"
  
. . .

Save something (pretty much anything) by creating an object

```{r}
#| code-fold: false
#| code-line-numbers: "1-2|3-6|7-8"
# A number
my_num <- 2 # Read as "my_num" gets a value of 2
# A function
my_fun <- function(name){
  cat("My name is", name)
}
# piece of text
my_name <- "JC"
```

## Creating "objects"

:::: {.columns}

::: {.column width='50%'}
They will appear in your **environment** pane

![](img/environment.png)

:::

::: {.column width='50%'}

And you can "call them" later in your console

```{r}
#| code-fold: false
#| error: true
my_num # Call your object in the console

my_num + 2 # Use your object in other operations

my_number # This line should fail.. Why?

my_fun(my_name) # Use your own functions
```

:::
::::

. . .

You can use `class()` to check what each thing is

```{r}
#| code-fold: false
class(my_num)
class(my_name)
```


# Combining objects

## Combining Atomic Objects

- You can combine atomic elements with function "`c()`"

- `c` stands for "`c`ombine"

. . .

```{r}
#| code-fold: false
colors <- c("red", "blue", "green", "orange", "black")

numbers <- c(1, 40, 1, 5, 6)

more_numbers <- c(my_num, numbers)
```

- The objects called `colors`, `numbers` and `more_numbers` are _vectors_ of characters and numbers

- Vectors are like columns in a spreadsheet

- Vectors have lengths: number of elements

. . .

```{r}
#| code-fold: false
#| results: false
length(colors)
```

```{r}
#| code-fold: false
#| echo: false
length(colors)
```


## Binary Operators

:::: {.columns}
::: {.column width='50%'}

```{r}
#| code-fold: false
2 + 2 # Addition

10 - 1 # Subtraction

10 * 3 # Multiplication

10 / 3 # Division

2^4 # Exponentiation

64 ^ (1/2) # Roots as powers...
```

:::{.callout-important}
In these examples the values are "printed" to the console (slide), never to be seen again
:::

:::

::: {.column width='50%'}
**_Arithmetic Operators:_**

- Stand between two values
- Perform arithmetic on _numeric vectors_ (or objects that can be coerced to them)
  - "coercion" here means "conversion"
  - `TRUE` or `FALSE` (logical values) can be "coerced" with ones and zeroes

:::

::::


## Binary Operators

:::: {.columns}

::: {.column width='50%'}
```{r}
#| code-fold: false
2 < 3  # Less than?
2 > 3  # Greater than?
2 <= 3 # Les than or equal to?
2 >= 3 # Greater than or equal to?
2 == 3 # Equal to?

# Also works with characters
"hotdog" == "sandwich" # Equal?
"JC" != "Juan Carlos" # Not equal, different from?
```
:::

::: {.column width='50%'}
**Relational operators**

- Also stand between two values
- Allow comparison of values in _atomic_ vectors

:::

::::


## Operating on Vectors

If the vector is numeric, arithmetic operations are applied to every element automatically

```{r}
#| code-fold: false
numbers <- c(1, 40, 1, 5, 6)
numbers * 2
```

- Arithmetic operations don't work on character vectors

. . .

```{r}
#| code-fold: false
#| error: true
colors <- c("red", "blue", "green", "orange", "black")
colors * 2
```

:::{.callout-note}
What does the error message above mean?
:::

## Combining Vectors of Different Classes

- R's basic class is _data.frame_
- Different classes between columns is OK, not within
- All vectors **must** be the same length

. . .

Build data.frame from vectors

```{r}
#| code-fold: false
#| results: false
#| code-line-numbers: "2|3|4-6"
# Build my vectors
colors <- c("red", "blue", "green", "orange", "black") # For five colors
numbers <- c(1, 40, 1, 5, 6)                           # For five numbers
# Column names are automatically assigned
data.frame(colors,
           numbers)
```

```{r}
#| echo: false
data.frame(colors,
           numbers) |> 
  gt::gt()
```


## Combining Vectors of Different Classes

Build data.frame straight from atomic elements

```{r}
#| code-fold: false
#| results: false
# I must assign column names
data.frame(my_colors = c("red", "green"), # Note use of " = " and not " <- "
           my_numbers = c(1, 2))
```

```{r}
#| echo: false
data.frame(my_colors = c("red", "green"), # Note use of " = " and not " <- "
           my_numbers = c(1, 2)) |> 
  gt::gt()
```


. . .

:::: {.columns}

::: {.column width='50%'}
Using vectors of different lengths fails

```{r}
#| code-fold: false
#| error: true
data.frame(colors = c("red", "green", "blue"),
           numbers = c(1, 2))
```

:::

::: {.column width='50%'}
Unless they can be recycled, so be careful

```{r}
#| code-fold: false
#| results: false
data.frame(colors = c("red", "green", "blue", "orange"),
           numbers = c(4, 2))
```

```{r}
#| echo: false
data.frame(colors = c("red", "green", "blue", "orange"),
           numbers = c(4, 2)) |> 
  gt::gt()
```
:::

::::


## Combining Vectors of Different Classes

Build a data.frame and save it to an object

```{r}
#| code-fold: false
my_data <- data.frame(colors = c("red", "green"),
                      numbers = c(1, 2),
                      letters = c("A", "B"))

# Check class
class(my_data)
```

data.frames have two _dimensions_

```{r}
#| code-fold: false
dim(my_data)

nrow(my_data)

ncol(my_data)

dim(EVR628tools::data_lionfish)
```

## data.frames are step 1 in tidy data

They allow us to adhere to the standards described in Week 2:

- Each column will be a _variable_
- Each row is an _observation_
- Cells contain _values_

. . .

:::: {.columns}

::: {.column width='50%'}
Tidy data
```{r}
#| echo: false
tidy_turtles <- data.frame(spp = c("C. mydas", "C. caretta"),
           sex = c("Female", "Male"),
           carapace_length = c(23, 24))

tidy_turtles
```

:::

::: {.column width='50%'}
Not tidy data
```{r}
#| echo: false
not_tidy_turtles <- tidy_turtles |> 
  t() %>%
  as.data.frame() |> 
  magrittr::set_colnames(value = c("Org 1", "Org 2")) |> 
  rownames_to_column(var = "variable")

not_tidy_turtles
```

:::

::::


## Tibbles vs data.frame

- Tibbles are a special type of data.frame used in tidyverse and spatial libraries

- They work in the same way

. . .

```{r}
#| code-fold: false
library(tidyverse)
tibble(colors,
       numbers)
```

- But _cells_ can contain objects that are not atomic

. . .

```{r}
#| code-fold: false
tibble(colors = c("red", "green"),
       numbers = c(1, 2),
       weird_column = list(c(1, 2, 3),
                           c("a", "b", "c")))

```

## Tibbles vs data.frame

Tibbles are also smart

- They display their dimensions
- And let you know data have been omitted

. . .

```{r}
#| code-fold: false
data_lionfish
```


## Indexing and subsetting objects with `[]`

Accessing elements within an object based on their position

**Vectors**

```{r}
#| code-fold: false
colors <- c("red", "blue", "green", "orange", "black") # Create a character vector of colors
```

. . .

I can extract the first element with:

```{r}
#| code-fold: false
colors[1] # Extract first element
```

. . .

Extract the first and third elements

```{r}
#| code-fold: false
colors[c(1, 3)] # Extract elements 1 and 3
```
. . .

Extract elements 2 through 4

```{r}
#| code-fold: false
colors[2:4] # Extract elements 2,3, 4
```


## Indexing and subsetting objects with `[]`

**data.frames and tibbles**

data.frames are two-dimensional, so we use two numbers: `[rows, cols]`

. . .

```{r}
#| code-fold: false
my_data
```
. . .

Extract the value for the second observation anad third variable

```{r}
#| code-fold: false
#| eval: false
my_data[1 , 3]
```

. . .

```{r}
#| echo: false
my_data[1 , 3]
```

. . .

Extract values for first observation across all variables, implicitly

```{r}
#| code-fold: false
#| eval: false
my_data[1, ] # row one, all columns
```

. . .

```{r}
#| echo: false
my_data[1,] # row one, all columns
```

. . .

Extract values for first variable across all observations, implicitly

```{r}
#| code-fold: false
#| eval: false
my_data[ , 1]
```

. . .

```{r}
#| echo: false
my_data[ , 1]
```

## Extracting data.frame columns with `$`

- Remember data.frames and tibbles are just collection of vectors
- You can get the variable (column) out as a vector using `$`
- This is why we like tidy data

. . .

```{r}
#| code-fold: false
ids <- data_lionfish$id
```

- And then use `[]` on the resulting vector
- For example, extract the first 10 ids

. . .

```{r}
#| code-fold: false
ids[1:10]
```

- This also works

. . .

```{r}
#| code-fold: false
data_lionfish$id[1:10]
```



## Indexing with `[]` and modify with ` <- `

For vectors

```{r}
#| code-fold: false
colors <- c("red", "blue", "green", "orange", "black") # Create a character vector of colors
colors
```

. . .

Let's modify red to white

```{r}
#| code-fold: false
colors[1] <- "white" # The first element of "colors" takes the value "white"

colors
```

. . .

Number of elements indexed must match number of elements assigned

```{r}
#| code-fold: false
#| error: true
#| warning: true
colors[1] <- c("white", "yellow")

colors
```

## Indexing with `[]` and modify with ` <- `

For data.frames

```{r}
#| code-fold: false
my_data
```

. . .



```{r}
#| code-fold: false
my_data[1, 3] <- "this is not a letter"
```

Which value will change?

. . .

```{r}
#| code-fold: false
my_data
```

# Functions

## Functions

A function:

- Is a block of code which only runs when it is called
- takes arguments...
- does something to them
- returns an object that used the arguments passed
- A function can do anything you want it to do

## Functions

For example, calculate the mean $\bar{x} =  \frac{\sum_{i = 1}^Nx_i}{N}$

"_Sum of all values from 1 to N, divided by the number of values_"

. . .

```{r}
#| code-fold: false
# Example: calculate mean lionfish length by hand
sum(data_lionfish$total_length_mm) / length(data_lionfish$total_length_mm)
```

. . .

If you have to do this for multiple variables, you might want to use a `function`

```{r}
#| code-fold: false
# Example: calculate mean lionfish length using a built-in function
mean(x = data_lionfish$total_length_mm)
```

. . .

And if the function doesn't exist, you can create one yourself

```{r}
#| code-fold: false
my_mean <- function(var) {
  mean <- sum(var) / length(var)
  return(mean)
}
# Example: calculate mean lionfish length using a user-defined function
my_mean(var = data_lionfish$total_length_mm)
```

## Note 3: Calling Functions

:::{.callout-note}
- R comes with many built-in functions
- R packages typically provide additional functions
- "Calling" a function is like invoking it
:::

. . .

```r
function_name(argument1 = value1, argument2 = value2, ...)
```

- Different functions take different numbers and types of arguments
- R uses "named arguments", which often have an order
- If you don't use the names, you _must_ follow the order

## Note 1: Calling Functions

If you don't use the names, you _must_ follow the order

This fails:

```{r}
#| code-fold: false
#| error: true
ggplot(aes(iso_time, pressure),
       data_milton) +
  geom_line()
```

. . .

But this works:

```{r}
#| code-fold: false
#| fig-height: 2
#| fig-width: 4
ggplot(mapping = aes(iso_time, pressure),
       data = data_milton) +
  geom_line()
```


# Pipes and pipelines

## Pipes

Imagine having the following numeric vector

```{r}
#| code-fold: false
numbers <- c(1, 5, 2, 7, 9, 2, 3, 6, 3, 2, 1, 1, 6, 8, 3, 2, 1, 6, 1, 2, 8, 3,
             6, 8, 9, 0, 5, 3, 2, 1, 2, 6, 9, 2, 3, 6, 3, 2, 1, 1, 6, 8, 3, 2)

```

. . .

And wanting to know how many **unique** numbers there were

. . .

You would want to use `unique()` and then `length()`

. . .

Before **2013** you had two options:

:::: {.columns}

::: {.column width='50%'}

1: Call each function at a time

```{r}
#| code-fold: false
unique_values <- unique(numbers) # Forces you to create objects
unique_values
length(unique_values)
```

:::

::: {.column width='50%'}

2: Use nested functions

```{r}
#| code-fold: false
length(unique(numbers)) # Doesn't take much space, but hard to read
```


:::

::::

. . .

Neither is conducive to longer pipelines of chained operations


## Pipes After 2013

The `magrittr` package introduced the _pipe_ operator "`%>%`"

![The Treachery of Images by René Magritte](http://adolfoalvarez.cl/blog/2021-09-16-plumbers-chains-and-famous-painters-the-history-of-the-pipe-operator-in-r/MagrittePipe.jpg){.nostretch fig-align="center" width="30%"}

. . .

The pipe was later popularized by `{dplyr}`

. . .

```{r}
#| code-fold: false
library(magrittr) # Load the magrittr package

# Build a pipeline
# Read %>% as "goes into"
numbers %>%      # Numbers go into unique
  unique() %>%   # The set of "unique numbers" go into "length"
  length()
```


## Pipes Since 2021

The R community saw the usefulness of this and developed a "native" pipe "`|>`"

. . .

You no longer need to load a package to use a pipe

```{r}
#| code-fold: false
numbers |> 
  unique() |> 
  length()
```

. . .

Other languages have pipes:

- bash uses `|`
- Julia uses `|>`
- python uses `|` in the `Pipe` module but `.pipe()` in pandas
- In a sense, `{ggplot2}` uses `+`
  - Hadly Wickham has mentioned he regrets this


# Code _style_

Helping others (and future you) read your code

## Comments

- Text embedded within your script for humans to read

- Helps other people (including future you) understand what's going on

- We use the `#` sign to prevent the computer from reading it
  - Works in R, Python, Make, Julia, SQL

## Comments: Some guidelines

- What are you doing?
- Why are you doing it _that way_?
  - Focus on explaining _why_ you did something, not _what_ you are doing (or _how_)
- Try to keep your comments within the vertical line show in RStudio

. . .

Is this helpful?

```{r}
#| code-fold: false
# A function
my_fun <- function(name){
  paste("My name is", name)
}
```

. . .

How about this?

```{r}
#| code-fold: false
#| code-line-numbers: "1|2|3|4"
# Define a function called "my_fun"
my_fun <- function(name){      # Takes a parameter called "name"
  paste("My name is", name)    # Combines it with a part that says "My name is"
}                              # End of "my_fun"
```


## Comments: Common mistakes

Too much commenting

```{r}
#| code-fold: false
# Build a function that takes a number called "x" and multiplies it by two and then adds 10
my_other_fun <- function(x){   # Start function
  y <- (2*x) + 10              # This line takes the value of x and multiplies it by two in (2*x). It then adds 10 in the part that says "+10"
}
```

. . .

Better, but forgot to use "`#`"

```{r}
#| code-fold: false
#| error: true
#| code-line-numbers: "|1"
Define my second function
my_other_fun <- function(x){ # Start function
  y <- (2*x) + 10            # Perform the calculation
}
```

## Sectioning with comments

- A script contains more than one bit of code, often dozens of lines

- R can detect up to 6 levels, as indicated by the number of "`#`"

. . .

:::: {.columns}

::: {.column width='50%'}
```r
################################################################################
# Description goes here
################################################################################

# SET UP #######################################################################

## Load packages ---------------------------------------------------------------

## Load data -------------------------------------------------------------------


# PROCESSING ###################################################################

## Some step -------------------------------------------------------------------


# VISUALIZE ####################################################################

## Another step ----------------------------------------------------------------


# EXPORT #######################################################################

## The final step --------------------------------------------------------------
```
:::

::: {.column width='50%'}
![](img/outline_comments.png){.nostretch fig-align="center" width="90%"}
:::

::::


## Naming conventions

```{r}
#| eval: false
#| code-fold: false
i_use_snake_case                   # This is my preference

otherPeopleUseCamelCase            # This sometimes works

some.people.use.periods            # This is dangerous, especially in python

And_aFew.People_RENOUNCEconvention # You need help

ALL_CAPS                           # Reserved for super important stuff
```

- [Google Code Style Guide](https://google.github.io/styleguide/)


## Spaces

Use spaces:

- around mathematical operators apart from `^` (i.e. `+`, `-`, `==`, `<`, …)
- and around the assignment operator (`<-`).

. . .

```{r}
#| eval: false
#| code-fold: false
# Strive for
y <- (m * x) + b

# Avoid
y<-(m*x)+b

# Avoid
 y <- ( m * x ) + b
```

- No spaces around parentheses for regular function calls
- Always put a space after a comma, just like in standard English.

. . .

```{r}
#| eval: false
#| code-fold: false
# Strive for
mean(x, na.rm = TRUE)

# Avoid
mean (x ,na.rm=TRUE)
```

# Extra notes

## Note 2: Matrices and Arrays

:::{.callout-note}
- All columns must be of the same class
- You can do linear algebra on them
- Matrices are 2-dimensional arrays, which can be multidimensional
:::

. . .

```{r}
#| code-fold: false
numbers <- c(1, 40, 1, 5, 6)   
mat1 <- cbind(numbers, numbers) # cbind is for "column binding"
mat1
```

. . .

```{r}
#| code-fold: false
mat2 <- rbind(numbers, numbers) # rbind is for... "row binding"
mat2
```

. . .

```{r}
#| code-fold: false
mat3 <- matrix(data = c(1, 2, 3, 4, 5, 6), nrow = 3) # You can also build it from scratch
mat3
```

## Note 3: Lists

:::{.callout-note}
- We won't cover lists yet
- lists are flexible
- lists combine vectors of different class and sizes
- The flexibility may be great for the programmer, but not for the user
- data.frames and tibbles are both _technically_ lists of equally-sized vectors
:::


